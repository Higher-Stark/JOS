# Lab 3 notes

## Lab 内容简介

Lab 3 会在系统启动后创建第一个用户态进程，本次lab只会有一个用户态进程，后续的lab会产生多个用户太进程。

JOS的用户态进程称为一个environment，与xv6的process有所不同。
JOS下只会有一个活跃的environment,所以不是每个env都会有一个Trap frame。JOS中只有一个trap frame。

多任务、不同的等级要求我们记录每个env，从而实现对envs的管理。主要有以下几点：

1. env的创建
2. env的执行
3. env的终结
4. env运行中系统调用与异常

这一些点会牵涉到每个env内存表的构造、内存的分配映射，程序文件的加载，trap frame的使用等。

_本次lab会涉及一些gcc的内联汇编代码，但对本次lab并不一定需要使用到_

## Way Through the Lab
### Part A
#### Exercise 1

JOS 内核维护了整个系统的environments，通过
```C
struct Env *envs = NULL;		// all environments
struct Env *curenv = NULL;		// current env
static struct Env *env_free_list;	// Free environment list
```
三个变量。`envs`是系统中所有environments所在的数组，分配空间在执行`page_init()`之前，使用`boot_alloc()`分配数组内存。
`env_free_list`要求第一个被分配的environment是`envs`数组的第一个，将`env_free_list`指向`envs`即可。`env_free_list`是个链表结构，只需要在初始化envs数组时将前一个指向后一个就可以了。

#### Exercise 2

Lab 文档中提到 JOS 的内核内嵌了一些用户态的程序，以二进制的ELF格式。
这样就可以直接从内存中复制，而不需要像`main.c`中的`bootmain()`函数一样从磁盘读取。

`env.c`中需要我们实现的有`env_init()`, `env_setup_vm()`, `region_alloc()`, `load_icode()`, `env_create()`, `env_run()`这几个函数。

* `env_init()`函数调用发生在`mem_init()`之后，负责初始化`envs`这一数组和`env_free_list`。
  同时还要对每个CPU进行部分初始化。
* `env_setup_vm()`函数完成对`env` `UTOP`以上的虚拟内存的映射。
  因为对于所有的environments来说，初始化时`UTOP`以上的虚拟地址空间都是一样的（除了`UVPT`所在的那一个page以外），初始化时只需要将内核的page directory tabl复制过去即可。
  User env的page directory table所在的页需要手动管理它的reference counter，`page_free()`才能正常地free这一page。
* `region_alloc()`这个函数分配`len`字节的物理内存空间，并映射到environment的`va`虚拟地址空间。  
  但真实情况下物理内存的分配都是以page为最小单位，所以需要对`va`向下对齐，对`va + len`向上对齐，再从物理内存中分配相应大小的资源。
* `load_icode`函数将一个二进制可执行文件加载到一个environment中，首先检查二进制文件是否是ELF格式的可执行文件，再接着读取ELF文件的头部，将ELF文件的`.text`, `.data`等部分通过`region_alloc()`加载到相应的内存地址。  
  因为ELF的`.text`等部分应加载到environment对应的内存空间，所以在复制之前需要将`CR3`寄存器变成environment的page directory的物理地址。在复制完成后恢复到kernel的page directory的物理地址。
* `env_create()`根据给定的二进制文件创建一个environment，并设置其类型为给定的`type`。
* `env_run()`的发生意味着context switch，如果`curenv`非空且处于正在运行状态，就将其状态置为可运行。将`curenv`改为新的environment，再把新的environment标为正在运行，切换`CR3`，最后需要`env_pop_tf()`将trap frame中的状态恢复。

#### Exercise 3

* Interrupt
  
  中断有可被mask延迟处理和不可mask之分，操作系统会调用相应的interrupt handler来处理中断。
  中断一般由外部产生。

* Exception
  
  异常一般由程序内部产生，如INT 0x30等，通常被称为软中断。

多个异常和中断会根据优先级进行处理。

异常和中断都是受保护的控制转移，使得控制从用户态转换到内核态(__CPL = 0__)。
Intel 将中断描述为外部产生的异步的事件，而异常是内部同步产生的事件。

x86采用了两种机制来实现受保护的控制转移，__The Interrupt Descriptor Table__ 和 __The Task State Segment__。

* The Interrupt Descriptor Table

x86支持256个不同的中断或异常，对应0-255个中断向量。从每个中断向量处理器会将中断handler的指令地址载入`EIP`寄存器，另外还有一个值，载入`CS`寄存器，这个值中有一位用于指示handler的运行级别，0指内核态，1对应用户态。_JOS中所有异常都在内核态中处理。_

* The Task State Segment

程序进入内核态需要把进入前用户态的状态进行保存，比如`EIP`和`CS`寄存器的值。
x86上会把`SS`, `ESP`, `EFLAGS`, `CS`, `EIP`和出错码（可选）保存到task state segment中。
_JOS 中仅用task state segment的`ESP0`和`SS0`来说明内核栈的位置，不使用TSS的其他属性。_

##### 中断和异常的类型

> All of the synchronous exceptions that the x86 processor can generate internally use interrupt vectors between 0 and 31, and therefore map to IDT entries 0-31.  
> Interrupt vectors greater than 31 are only used by software interrupts, which can be generated by the `int` instruction, or asynchronous hardware interrupts, caused by external devices when they need attention.

本次lab需要实现0-31号和48号中断的处理。

#### Exercise 4

JOS的`Trapframe`结构如下，
```C
struct Trapframe {
	struct PushRegs tf_regs;
	uint16_t tf_es;
	uint16_t tf_padding1;
	uint16_t tf_ds;
	uint16_t tf_padding2;
	uint32_t tf_trapno;
	/* below here defined by x86 hardware */
	uint32_t tf_err;
	uintptr_t tf_eip;
	uint16_t tf_cs;
	uint16_t tf_padding3;
	uint32_t tf_eflags;
	/* below here only when crossing rings, such as from user to kernel */
	uintptr_t tf_esp;
	uint16_t tf_ss;
	uint16_t tf_padding4;
} __attribute__((packed));
```
可以看到JOS中需要软件保存的是`trapno`, `tf_ds`, `tf_es`和`tf_regs`，每个trap handler中在跳至`_alltraps`之前`trapno`已经压栈，`_alltraps`需要把`DS`和`ES`保存下来，然后`pushal`一条汇编指令会把`PushRegs`对应的寄存器全部保存下来。

`_alltraps`会调用`trap()`函数，`trap()`会返回，`_alltraps`需要把`Trapframe`中保存的状态恢复回去，最后`iret`返回到用户态。

不清楚为什么这个lab里在`trapentry.S`中定义一个全局的`vectors`指向所有trap handler这一数组, `trap.c`中却并不能正确的得到一个函数数组，采用文档中`void NAME()`的方法将每个handler设置到IDT中。

### Part B

#### Exceptions for page fault, breakpoint and system call

All these exceptions and interrupts can be achieved by interrupting an appropriate number. Then dispatcher invokes the coresponding handler.

#### Exercise 8

`sysenter`是一个比`int 0x30`更快的实现系统调用的方法，能使用户态的代码快速调用内核态的程序。

`sysenter`将参数保存在寄存器中，将`IA32_SYSENTER_CS`指向的内核程序地址加载到`CS`，将`IA32_SYSENTER_ESP (0x175)`指向的内核栈地址加载到`%esp`，将`IA32_SYSENTER_EIP (0x176)`对应的`sysenter`的`handler`地址加载到`%eip`，并将CPU从Ring 3切换到Ring 0，`EFLAGS`也会被清空。这样程序就快速地进入了内核态。

`sysenter`内根据`syscall`的调用规则，将寄存器中的参数压栈，然后调用`syscall`。`syscall`返回后，调用`sysexit`返回到用户态。

`sysexit`返回时会将`CS`设为`IA32_SYSENTER_CS + 16`，将`%eip`设为`%edx`，将`SS`设为`IA32_SYSENTER_CS + 24`，将`%esp`设为`%ecx`。而进入`sysenter`的handler前，用户态`sysenter`下一条指令和`%esp`分别保存在`%esi`和`%ebp`中，需要手动设置。

`sysenter`没有`trap frame`，所以调用`sysenter`前，需要手动保存寄存器的值并在调用后恢复。

#### Exercise 9

`curenv`是内核的数据结构，不应被用户态访问，`thisenv`做到了隔离。

_之前在`syscall`中没有注册`sys_env_destroy`的handler，导致程序落入了`args_exist`最后的循环中, 程序检查还是很重要。_

#### Exercise 10

JOS使用`sbrk`来增加`env`的堆大小，需要在`struct Env`中加入一个`brk`值表示当前堆顶的内存地址。
因为文档中说明`sys_sbrk`只增大堆，不需要为`struct Env`记录堆底的内存地址或者当前堆的大小。

根据JOS的虚拟内存空间分布，堆的位置在`.text`, `.data`, `.bss`等上部，这些部分在`load_icode`中会被加载到内存中，并且大小不会在运行时改变。堆向上生长，上方有用户态的运行栈，向下生长，所以将堆顶的初始位置高于`.text`, `.data`, `.bss`等的任何一部分，就可以了。

增大的操作与`region_alloc`相似，但是`region_alloc`会确保分配的内存空间一定会覆盖要求的`va, va+len`。但是在这里，`brk`所在的页必然是已经分配的了，一开始在`load_icode`中由于某一部分数据的需要，分配了一定的页，最后一页恰好还有剩余的空间，`brk`就可以利用这部分剩余的空间。因此在实现`sys_sbrk`使对`brk`做roundup后再看是否有必要分配新的页。

#### Page fault and Memory protection

内存保护很重要的一点是内核对page fault的处理，

1. 如果内核访问一个地址出错，而这个地址是内核自己的一些数据所在的地址，那么内核应当panic，说明内核存在bug。如果是用户态程序传递的，那么内核就不应当panic。因此内核需要能区分传入指针是自己的还是用户态的
2. 如果内核访问一个用户态程序的指针发生page fault，那么很可能这个指针指向的是一个用户态无法访问的地址，如果内核不做检查，就可能导致数据泄露，有安全隐患。

#### Exercise 11 

检查page fault是否发生在内核态，只需要看trap frame的`CS`字段的低2位，如果是0，说明内核发生了page fault。
否则就是用户程序发生了page fault。对用户态的page fault，如果地址大于ULIM，或者遍历用户态程序的page directory，不存在对应的页或者没有足够的权限,说明都属于非法访问。

* 内核`backtrace`时，会读取`%ebp`的值，从而访问上一级栈地址。从输出看，`backtrace`首先输出了内核monitor的栈，然后找到用户态的栈，在访问用户态的栈时，由于内核并没有数据放在对应的内存地址，所以触发了内核的page fault。

#### Exercise 12

程序直接调用`sys_cputs()`访问内核空间，并不会发生page fault，但是用户态并不能访问内核空间，直接会出错程序结束。内核并不会page fault。

#### Exercise 13

程序通过`sgdt`获得GDT地址后，调用系统函数`sys_map_kernel_page`将GDT映射到了一块用户态内存，并向GDT中插入了一条用户态的callgate，使用`lcall`将程序切换到ring0并访问内存空间，并且向控制台输出。最后通过`lret`切换回ring3，从而使得用户态程序在用户态下快速调用特权函数。